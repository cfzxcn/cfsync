[启动流程和grub故障排错](https://www.bilibili.com/video/BV1cT411P7sC?p=110&vd_source=37dcb67dc2fcca470ec53b1511e0412f)
# co6 的启动管理
linux=内核+根文件系统rootfs（程序和相应的库）
![[Pasted image 20230916114052.png|700]]
![[Pasted image 20230916115030.png|900]]
![[Pasted image 20230916115328.png|600]]
![[Pasted image 20230916115936.png|800]]
**post**，开机后，cpu会读取内存空间中固定位置的特定程序，这个程序是bios自动从ram中加载到内存中的，然后进行启动，这是约定好的。由硬件完成

bios 硬件post后---bootloader连接硬件和操作系统
![[Pasted image 20230916122143.png]]
![[Pasted image 20230916122624.png]]
![[Pasted image 20230916122447.png]]
## co6的mbr分区格式启动过程
bios 硬件post后---硬盘引导---

1st stage：读取硬盘启动加载器bootloader即grub（即硬盘第1个扇区即mbr的前446bytes）启动计算机。
- 第一个扇区有3部分，共512字节，hexdump -C -n 512 /dev/sda，
	- 其中前446bytes为第1部分，存放了grub的一部分，可称为：1nd stage，用来加载2st stage；
	- 第2部分：64bytes存放分区表；
	- 第3部分：最后2个bytes是55 aa的标记位

1.5 stage：mbr之后的27个扇区。grub为了加载2nd stage的/boot/grub/grub.conf去启动内核，先要识别/boot所在分区的文件系统，就要加载文件系统的驱动（管理文件系统是内核的功能之一，但此时，内核还未加载，那么文件系统还识别不了，所以为了解决此问题，需要辅助的添加一个1.5 stage，让它能识别2st stage文件所在分区的文件系统）。

2st stage：放在/boot/grub目录里。其中会加载/boot/grub目录里(co6)的菜单文件：grub.conf---加载linux内核kernel---开启系统第一个进程：init(<=co6)或systemd(>=co7)---加载一些服务---登录界面

所以grub是分散在硬盘上的不同位置，有的是文件方式，比如2st stage，有的是0101的二进制方式存放在磁盘上的。共同组合起来的组合软件。
![[Pasted image 20230916125217.png]]
![[Pasted image 20230916125646.png]]
modinfo xfs    #  可以查看驱动文件的路径
modinfo ext4
ll -h /lib/modules/2.6.32-754.el6.x86_64/kernel/fs/ext4/ext4.ko
![[Pasted image 20230920223833.png]]
### co6的1nd stage被破坏的第1种修复方法
- 破坏前先记录一下
![[Pasted image 20230920233335.png]]
- dd if=/dev/zero of=/dev/sda bs=1 count=446，破坏了第一个扇区的前446字节，用0填充，这就是grub的1nd stage出问题，导致启动找不到硬盘，硬盘失去启动功能
**1.13故障记录**
![[Pasted image 20231016145342.png]]

![[Pasted image 20230920233758.png]]
- hexdump -C -n 512 /dev/sda -v    #  加-v可看全部
- 关机后，为vm虚拟机添加一个nvme硬盘来模拟u盘
- reboot后，提示：
![[Pasted image 20230920235509.png]]
![[Pasted image 20230920235750.png]]
- 重启虚拟机时--看到vmware大图标时按一下esc，就能看到boot menu了，不要按多下，但这个菜单可看到光盘看不到u盘，所以可进入bios中设置u盘启动
- 或虚拟机测试时直接f2进入bios设置u盘启动
- co6用u盘进入救援模式---第三项：rescue installed system---使用shell---chroot /mnt/sysimage/，可以修复：grub-install /dev/sda---sync---sync。reboot或ctrl+alt+delete前，可以用hexdump -C -n 512 /dev/sda -v查看一下80 20之前有内容了
- 注：grub-install [ --root-directory=/ ] /dev/DISK
\#  --root-directory=指/boot的位置，就是根，默认也是根，所以一般省略不写。/dev/DISK是硬盘不是分区
![[Pasted image 20230916144019.png]]
测试成功！

![[Pasted image 20230916132851.png]]
### co6的1nd stage被破坏的第2种修复方法
两种方式哪种都行，第二种grub的方法，破坏后不用重启直接用grub测试，这个命令同时修复了1nd、1.5、2st三个阶段
![[Pasted image 20230921004928.png]]
上图提示可知：**第1个扇区往后数的27个扇区，就是1.5 stage**
### co6的1.5 stage被破坏的修复方法
dd if=/dev/zero of=/dev/sda bs=512 count=25 seek=1
\# seek=1，跳过目标的1个bs，即前512字节即第1个扇区（因为规定了bs=512，以512个字节为1个单位）；破坏第1个扇区后的25个bs，即25个扇区（这里测试没破坏到27个扇区，只破坏了1.5st的部分数据），即512\*25个字节。
现在reboot将会有个光标一直闪烁，无法启动，和破坏1st的启动故障不同。因为：1.5st被破坏了，但1st是完好的，所以系统是可以启动的，就会尝试使用1.5st加载文件系统，但现在1.5st被破坏了找不到文件系统所以卡住了。
救援方法和上面1st stage的方法一样，两种方法都行。救援模式下---grup-install /dev/sda。reboot后能看到菜单，说明已经进入2en stage

**注：grub.conf是无法用grub-install生成的，只能手工写。分区表是数据，每个人的分区策略不同，修复不了，可以用相同分区的另一台主机的备份的分区表来还原；grub是程序，出厂就设定好的，固定的，所以可以修复**

**1.5 stage作用：为了加载grub的2st，2st在/boot/grub，要访问/boot，就要加载1.5st的驱动，才能识别/boot
initramfs...：为了加载操作系统的根，提供根分区文件系统的驱动
## grub legacy管理
![[Pasted image 20230916143254.png]]
0.97版又叫grub legacy
rpm -qi grub
![[Pasted image 20230920213956.png]]
![[Pasted image 20230916175541.png]]
![[Pasted image 20230916183000.png]]
这个目录/boot/grub整个都来自于grub-0.97-...这个包，但/boot/grub/grub.conf不属于任何包，它是安装operator system生成的
![[Pasted image 20230916184137.png]]
![[Pasted image 20230916184244.png]]
![[Pasted image 20230916185554.png]]
所以，Apr 29  2020就是安装操作系统的时间
![[Pasted image 20230916184548.png]]
此文件同理
![[Pasted image 20230916184615.png]]
hexdump -C /boot/grub/stage1
![[Pasted image 20230916184909.png]]
放的是grub的备份
所以，虽然/boot/grub是2st stage用到的，但此目录下放了一些1nd、1.5、2 stage的备份文件。但它们不是启动时要用的，只是备份，删除也不影响启动

![[Pasted image 20230921112528.png]]
## co6的菜单文件：grub.conf
\# grub.conf generated by anaconda
anaconda：安装操作系统的安装向导的程序名称

splashimage=(hd0,0)/grub/splash.xpm.gz
\#  这是个压缩的背景图片文件，gzip -d splash.xpm.gz，解压后是：splash.xpm图片文件，可在win中用图像软件查看，就是个黑色背景

hiddenmenu
\#  默认会隐藏菜单，除非按任意键，去除此项，默认就会显示菜单了

- root (hd0,0)：内核所在硬盘、分区的名称
\#  hd0,0表示第一个硬盘的第一个分区；
\#  root：grub认为的根，grub先于内核加载，这个阶段，grub所认为的根就是第一个硬盘的第一个分区，即：/boot所在的分区，所以下面的：/vmlinuz...就是指：/sda1/vmlinuz，而sda1挂载到了/boot，所以也就是：/boot/vmlinuz
![[Pasted image 20230916200954.png]]
注：这里的根不是指内核加载后的根：
![[Pasted image 20230916201130.png]]

- root=/dev/mapper/vg_610-LogVol01
\#  加载内核后，内核就会尝试找硬盘操作系统真正的根，

- initramfs-2.6.32-754.el6.x86_64.img
\#   作用：挂载操作系统的根前需要文件系统、硬件驱动，就在这个压缩文件.img中，虚拟文件系统文件，这个包里是小型的linux的根文件系统。如果这个文件缺失了，将无法识别真正操作系统文件的根，就无法加载操作系统了
```shell
mv /boot/initramfs-2.6.32-754.el6.x86_64.img /tmp && cd /tmp
mv initramfs-2.6.32-754.el6.x86_64.img{,.gz}
gunzip initramfs-2.6.32-754.el6.x86_64.img.gz，解压后，文件体积会大很多，会删除解压前的压缩文件。再用file查看，可知是cpio文件，这是个打包格式，类似于tar
cpio -tv < filename    可以预览，可看到这就是一个小型的linux系统
cpio -idv < filename   可以解压
```
### initramfs 文件丢失的重建方法
reboot后只有光标闪烁，无法进入系统，可以进救援模式用如下方法重建
![[Pasted image 20230916210834.png]]
mkinitrd是个脚本，它调用了dracut命令，所以也可以直接执行dracut。
```shell
chroot /mnt/sysimage
mkinitrd /boot/initramfs-`uname -r`.img $(uname -r)
```
\#  后面要跟上内核版本$(uname -r)作为参数，生成后检查ls -l /boot下的此文件，文件名和grub.conf中的文件名必须完全一致
\#  sync---exit
### 重建co7被破坏的内核文件
```shell
rpm -qf /boot/vmlinuz-3.10.0-957.el7.x86_64
```
![[Pasted image 20230916232633.png]]
方法1：查看内核来自哪个包，rpm -ivh kernel...，但由于kernel包包含了很多文件，现在只丢失了一个kernel内核文件，而要装一整个包，有点小题大做，当然也可以修复

方法2：使用光盘上的内核还原，也可以：ll /misc/cd/isolinux/vmlinuz
![[Pasted image 20230916234243.png]]
删除内核reboot后应还能看到启动菜单，因为菜单是grup提供的，和内核无关。如果看不到，按任意键。
还进入rescue模式：
```shell
mount /dev/sr0 /media
rpm -ivh /misc/cd/Packages/kernel-3.10.0-1160.el7.x86_64.rpm --root=/mnt/sysimage --force
# 方法一，/boot里的文件，内核文件、initramfs文件都能生成
cp /media/isolinux/vmlinuz   /mnt/sysimage/boot/vmlinuz-`uname -r`
# 方法二，先chroot /mnt/sysimage切根，路径中就不用写/mnt/sysimage了
sync---exit
```
### co6启动菜单的e/a/c
**故障原因：**
将co6的grub.conf中的initrd /initramfs-2.6.32-754.el6.x86_64.img移到kernel /vmlinuz-2.6.32-754.el6.x86_64上，导致无法启动
**解决方法：**
- reboot后，提示：
![[Pasted image 20230921200423.png]]
- 按任意键进入菜单，选择有问题的菜单项，**按e编辑（a修改内核参数，c进入命令行）
- 出现新提示：
![[Pasted image 20230921200545.png]]
- 按d删除initrd /initramfs-2.6.32-754.el6.x86_64.img，这个删除不是把文件中的内容删除，只是临时性的修改菜单（改内存中的数据），所以这里修复好后，还要把硬盘上grub.conf中的内容调整
- 再按o追加一新行，再按e弹出一新界面编辑，输入：initrd /initramfs-2.6.32-754.el6.x86_64.img，这里支持tab补全，回车后按b启动，启动后再调整grub.conf即可
**co6启动时按esc可以输出详细的启动信息，类似grub.conf中去除quiet**
### co6单用户模式破解root口令
reboot后，任意键露出grub菜单，
- 菜单项按a或e：添加内核参数：quiet后输入1或single或S或s，回车然后进入**单用户模式，即：init 1（就是runlevel中的第1个级别），单用户有个功能就是破解root用户口令。
- 或菜单项按e编辑，quiet后输入1，回车再按b也行，也进了单用户模式
- 接下来，不用输入用户名，口令即可进入root用户的命令行界面
`echo cf | passwd --stdin root   &&   reboot
其实就是改了/etc/shadow文件
### 为grub菜单添加口令
```shell
grub-md5-crypt
#  单独生成加密grub口令，现在md5生成的口令已能破解，所以可用：
grub-crypt
#  生成sha512的加密口令，目前很安全不会被破解
password [--md5 | --encrypt ] string    #  grub.conf中添加的
```
![[Pasted image 20230921212408.png]]
![[Pasted image 20230917012543.png]]
![[Pasted image 20230921212447.png]]
reboot后grub菜单已经没有e,a,b的提示了，只有p提示输入口令，我测试直接回车就能越过密码，感觉没什么用，正常启动后也能编辑grub.conf去除这个密码

如果grub口令也忘记了，可用rescue模式解决，因为不用硬盘启动，所以硬盘的安全保护就无效了，直接修改grub.conf删除口令那行即可。把/etc/shadow中root的密码删除也能清空root密码
### 生成grub背景图片
![[Pasted image 20230917030519.png]]
第一步转换的文件名可自定义，如cf.xpm，grub.conf中的文件名可以不是splash.xpm.gz
### 删除co6的/boot后的修复
- 光盘进rescue救援模式
- chroot /mnt/sysimage
- 先修复内核，再修复grub，因为先修复grub，如果没内核的话，菜单里也没选项
- 修复vmlinux和initramfs两个核心文件即可，方法同上，
- cp /media/isolinux/vmlinuz /boot/vmlinuz-\`uname -r\`
- mkinitrd /boot/initramfs.img-\`uname -r\`.img \`uname -r\`
\#   以上两步不加版本号也行，当然，对应的grub.conf中也不加版本号
- grub-install /dev/sda   #  co7：grub2-install dev/nvme0n1
\#  修复grub的各个stage，但不能恢复grub.conf文件，只能手写
![[Pasted image 20230917021330.png]]
- ll /boot/grub，现在可看到已经生成了一堆文件，唯独缺失了grub.conf，所以下面的手工写
```shell
default=0
timeout=5
title CentOS 6   #  随便写
        root (hd0,0)  #  可省略
        kernel (hd0,0)/vmlinuz root=/dev/mapper/vg_610-LogVol01
        initrd   (hd0,0)/initramfs.img
```
\# 不记得文件名也可在vim中:r!ls /boot，读入ls /boot中的文件名；还可:!df查看哪个是root=后的**操作系统的根目录**
- sync---exit---reboot
- 注：co6实验成功，co7不成功！察看没有了/boot/efi分区
### `nomodeset`（作用：屏蔽显卡）
否则可能因为nvidia的显卡出现引导问题

## 删除/etc/fstab后的恢复
![[Pasted image 20230917023300.png]]
![[Pasted image 20230922002520.png]]
rpm -ivh /mnt/Packages/kernel.xxxx.rpm --root=/mnt/sysimage/ --force

## 删除/etc/fstab后lvm的恢复
经测试，co6中将fstab改名后，仍然可以进入系统，但lsblk查看有误：
![[Pasted image 20230922002247.png]]
![[Pasted image 20230922002809.png]]
删除fstab后，rescue模式中chroot /mnt/sysimage无法使用，因为这依赖于fstab文件
1. lvdisplay 找到卷组名，即：VG Name后的名字
2. lvm vgchange -ay VG_610    激活逻辑卷，然后ls /dev下可看到新增了VG_610的目录
3. 挂载找到的根目录，这样就可以在根目录下添加/etc/fstab文件了
![[Pasted image 20230922062743.png]]
4. df -hT  可看到逻辑卷的分区格式
5. parted /dev/sda print   可看到分区格式为msdos，说明没有efi分区，且能看到boot分区及格式为ext4
![[Pasted image 20230922063207.png]]
6. 现在blkid可看到所有
![[Pasted image 20230922063737.png]]
原来的备份
7. vi /mnt/sysimage/etc/fstab，:r! blkid   可以读入blkid的内容，完成！

## 加载kernel
grubr后就根据grub.conf中的内核路径来加载内核
![[Pasted image 20230917033037.png]]
ro root=/dev/mapper/vg_610-LogVol01
\#  以只读的方式挂载根
/sbin/init
\# ps aux和pstree -p中看到的第一个进程，它是所有进程的父进程
![[Pasted image 20230917033103.png]]

![[Pasted image 20230917034235.png]]
![[Pasted image 20230917034401.png]]
![[Pasted image 20230917035209.png]]
![[Pasted image 20230923103049.png]]

**重启时，在菜单项上按e编辑，在那行后输入3，可进入命令行模式**
### /etc/inittab中的子文件：
**/etc/init/下的文件都是系统启动时的初始化文件**
![[Pasted image 20230917041153.png]]
#### /etc/init/control-alt-delete.conf
\#  可以注释掉最后一行，避免按3个键重启
#### /etc/init/rc.conf
\#  记录了启动时要实现的服务，是早期的启动脚本，这些脚本在本文件中指定的路径下：exec /etc/rc.d/rc $RUNLEVEL，\$RUNLEVEL的值是0-6
##### /etc/rc.d/rc是个可执行文件
**service atd start = /etc/init.d/atd start**
\#  真正的脚本在/etc/init.d/下，安装服务时一般会自动生成一个脚本在此目录下。也可以写自己的，比如参考：cp -a /etc/init.d/{atd,cf}
##### /etc/init.d/cf   自定义脚本
```bash
#!/bin/sh
# chkconfig:   - 99 3
#  这行是服务脚本的标志性格式，不仅仅是注释，有作用，不可或缺。
#  345表示初始在345级别下开机自启，-表示在7种级别下初始都是不自启的；
#   S以99开头，K以3开头
#   由于是自定义脚本，所以往往可能有服务的依赖性，所以S开头的数字往后排较好，可用ls /etc/rc3.d/查看可能的字符次序，如：99；K开头的数字往前排较好，如：3
# description: cf test.
 . /etc/rc.d/init.d/functions    # 调用此函数，必需
prog="cf"
lockfile=/var/lock/subsys/$prog

start() {
    touch $lockfile
    action "Starting $prog: "
    sleep 5
}

stop() {
    rm -f $lockfile
# 需要加-f,否则restart会有提示，加上-f即使没文件可删除，也不提示
    action "Stopping $prog: "
}

restart() {
    stop
    start
}

reload() {
    restart
}

force_reload() {
    restart
}

rh_status() {
    # run checks to determine if the service is running or use generic status
#    [ -f $lockfile ] && echo "$prog is running..." || echo "$prog is stopped"
    if [ -f $lockfile ];then
        echo "$prog is running..."
    else
        echo "$prog is stopped"
    fi  
}
rh_status_q() {
    rh_status >/dev/null 2>&1
}

case "$1" in
    start)
#        rh_status_q && exit 0
        $1
        ;;
    stop)
#        rh_status_q || exit 0
        $1
        ;;
    restart)
        $1
        ;;
    reload)
#        rh_status_q || exit 7
        $1
        ;;
    force-reload)
        force_reload
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
        restart
        ;;
    *)
        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
        exit 2
esac
exit $?
```
chmod +x /etc/init.d/cf
然后可用/etc/init.d/cf status或service cf status控制了
chkconfig cf on && chkconfig --list cf
![[Pasted image 20230922181425.png]]
实际上就是在：/etc/rc[2|3|4|5].d/下添加了一个S99cf的软链接
![[Pasted image 20230922183144.png]]
![[Pasted image 20230922181449.png]]
实际上就是在：/etc/rc[2|3|4|5].d/下添加了一个K03cf的软链接
![[Pasted image 20230922181532.png]]
##### /etc/rc3.d/和/etc/rc5.d/两个目录下的文件
定义了两种运行级别下开机自启和不自启的服务
S开头的是启动的服务；K开头的是不启动的服务；
S95atd：95这个数字是从对应的真正的启动脚本来的/etc/init.d/atd
**所以所谓的runlevel：就是定义了不同级别下哪些软件启动或不启动**

**也可用ntsysv图形化方式更改当前runlevel下服务的开机自启或不自启，如果要在3模式下更改5模式的自启或不自启，可：ntsysv --level=5，由于ntsysv一次只能改一个模式，所以较少用，而用下面的**
##### chkconfig：设置及查询服务是否开机自启
![[Pasted image 20230917044448.png]]
同时改3和5级别atd服务不开机自启
![[Pasted image 20230917044658.png]]
不指定模式，默认是2，3，4，5，这4个模式是生产中用的主要模式
- chkconfig --add cf  好像和 chkconfig cf on 作用一样
- chkconfig --list    列出各种服务的状态
- chkconfig --del cf    删除cf服务，其实就是删除了/etc/rc*.d/\*cf的软链接
## 独立和非独立服务
由于co6大部分服务都是2345级别下开机自启，所以如果因为某个服务问题导致无法启动时，可以在开机菜单时按a，添加1，进行单用户启动，进入后，chkconfig --stop name或修改/etc/init.d/name。这样系统就能在2345级别时正常启动了
![[Pasted image 20230923101748.png]]
![[Pasted image 20230923123320.png]]
![[Pasted image 20230923101038.png|500]]
这是系统自带的初始化脚本，一般不用改
(4) 以可读可写方式重新挂载/etc/fstab（根文件系统），因为之前在grub.conf中是以只读方式挂载的，
![[Pasted image 20230923103341.png]]
![[Pasted image 20230923103707.png]]
### 在/etc/rc.d/rc.local添加服务以开机自启
![[Pasted image 20230923104805.png]]
- /etc/rc*.d/S99local，这是4个运行级别里的最后一个脚本
- echo '/etc/init.d/cf start' >> /etc/rc.d/rc.local    也实现了cf这个脚本开机自启，这是不使用chkconfig --add cf 设置开机自启的方法，但这种方法设置开机自启就不能用service来控制脚本了（脚本放在/etc/init.d中可以，service默认会找/etc/init.d下的脚本）
- 此方法co7/8也能用，但略有区别，co6上/etc/rc.d/rc.local 默认有执行权限，但co7/8中此文件默认没有执行权限
### 非独立服务
依赖xinetd超级守护进程启动、唤醒的服务叫非独立服务
yum install telnet-server   安装前如果系统并没安装xinetd，它会作为依赖被安装
安装xinetd后，chkconfig --list可看到这些非独立服务，当有访问这些非独立服务的请求时，xinetd用来唤醒它们
![[Pasted image 20230923114415.png]]
- off表示不受xinetd控制，不能被它激活，可用命令或改文件的方法将它们变为on
	- 这些非独立服务其实是xinetd的子服务，它们的配置文件在/etc/xinetd.d。配置文件中disable         = no就能把chkconfig --list中的结果变为on
	- chkconfig telnet off/on
**启动非独立服务要满足两个条件：
1. xinetd服务已启动
2. ~~要有访问请求
3. xinetd服务激活非独立服务
![[Pasted image 20230923122417.png]]
lsof可查看xinetd在监听23端口
客户端访问：telnet 192.168.1.167
### 第一个进程/sbin/init后的启动流程
第一个进程/sbin/init-->/etc/inittab，该文件定义了运行级别如3-->所有服务加载前的初始化脚本/etc/rc.d/rc.sysinit（由/etc/init/rcS.conf调用）-->/etc/rc3.d/-->加载该目录下以S开头的服务-->/etc/rc.d/rc.local-->登录界面
![[Pasted image 20230923123923.png]]
[co6启动流程图](http://s4.51cto.com/wyfs02/M02/87/20/wKiom1fVBELjXsvaAAUkuL83t2Q304.jpg)
![[Pasted image 20230923133050.png]]
